\documentclass[journal,transmag]{IEEEtran}

\usepackage{}
%\usepackage[pdftex]{graphicx}
% declare the path(s) where your graphic files are

%\graphicspath{IMAGES/}
%\DeclareGraphicsExtensions{.pdf,.jpeg,.png,.jpg}
\usepackage{graphicx}
\usepackage{amsmath}
\interdisplaylinepenalty=2500
\usepackage{algorithmic}
\usepackage{array}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfon =sf]{subfig}
\usepackage{dblfloatfix}
\usepackage{url}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}

\lstset{
	escapeinside={/*@}{@*/},
	language=Java,	
	basicstyle=\fontsize{8.5}{12}\selectfont,
	numbers=left,
	numbersep=2pt,    
	xleftmargin=2pt,
	frame=tb,
	columns=fullflexible,
	showstringspaces=false,
	tabsize=4,
	keepspaces=true,
	showtabs=false,
	showspaces=false,
	morekeywords={inline,public,class,private,protected,struct},
	captionpos=b,
	lineskip=-0.4em,
	aboveskip=10pt,
	extendedchars=true,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941},
}

% correct bad hyphenation here
%\hyphenation{-ing}

\begin{document}

\title{Optimising a genetic algorithm using parallelization}

\author{\IEEEauthorblockN{Emils Pinkis, 40122269\IEEEauthorrefmark{1}}
\IEEEauthorblockA{\IEEEauthorrefmark{1}School of Computing,
Edinburgh Napier University, Edinburgh}% <-this % stops an unwanted space

\thanks{}}


%\markboth{What a fucking fantastic header}{}
% The only time the second header will appear is for the odd numbered pages after the title page when using the twoside option.

\IEEEtitleabstractindextext{
\begin{abstract}
    This is an abstract.
\end{abstract}

\begin{IEEEkeywords}
    Napier, what(), \LaTeX, OpenMP, multithreading.
\end{IEEEkeywords}}

\maketitle

\IEEEdisplaynontitleabstractindextext

\IEEEpeerreviewmaketitle

\section{Introduction}
 
%\IEEEPARstart 

\section{Introduction}%}
	Evolutionary algorithms are often used to deal with computationally complex problems,
        as instead of computing a perfect solution, a set of random solutions is iterated upon
        filtering out best fitting solutions until an arbitrary limit is hit. It is crucial for
        a problem to have a fitness function for any given solution, otherwise an evolutionary
        algorithm is impossible for such a solution. Likewise, the fitness function has to be
        simple and fast, as it would be used to index and compare a set of solutions. Evolutionary
        algorithms lend themselves well to parallelization as each solution of a new set of solutions
        does not depend on other new solutions, only on previous solutions. Each solution set is called
        a generation - the initial generation is randomly generated. Each subsequent generation
        is created by generating new solutions by combining two random solutions from the previous
        generation and randomly mutating parts the resulting solutions.
        

	
	\subsection{A subsection}
		\lstinputlisting[caption = A code listing.]{./source/hello.cpp}

\subsection{Project scope}
        The project will compare different OpenMP parallelization approaches to a manual multithreading
        attempt. SIMD optimizations will not be attempted as the given evolutionary algorithm 
        is limited by random number generation. For large enough population sizes, GPGPU frameworks
        such as Cuda or OpenCL might be useful, however these are deemed out of scope.
	
\subsection{Methodology}
        To showcase how an evolutionary algorithm can be parallelized, an example implementation
        has been used, running in a single thread. To identify parts of the program which might
        bring an increase in performance when parallelized, Callgrind, a profiling tool will be 
        used. Parallelization will be attempted by manually threading the application and also 
        using OpenMP. To parallelize the program, certain parts of it will be changed to ensure
        memory safety. The programs will be ran on an Intel Core i5-3320M in isolation, 100 times
        for each test case. All code is compiled using GCC's G++ version 6.21. The experiment will
        test whether or not the randomness of the genetic algorithm has an impact on what method
        of parallelization is more effective across larger generation sizes.
        The given example evolutionary algorithm has these input parameters:
        \begin{itemize}
            \item \textbf{Population size} - size of each solution set
            \item \textbf{Gene length} - size of each atomic part of a given solution
            \item \textbf{Number of elites} - number of elite solutions that will be selected to be over from the last generation
            \item \textbf{Number of elite replication} - number of replications for each elite that will be carried over to the next generation
            \item \textbf{Crossover rate} - proportion of the population that will generate offspring
            \item \textbf{Mutation rate} - probability of a mutation occurring for a given solution
        \end{itemize}
        All of the parameters will remain static except for the population size,  to predictably
        increase the runtime of a program, as for everything else it is assumed that the genetic 
        algorithm is a black box. The program will be tested with a varying thread count to 
        see whether the algorithm is ultimately compute bound and parallelized successfully.


\section{Evolutionary algorithm}
        \subsection{Initial analysis} 
        Profiling the application.
	
\section{Section 4}
	\lipsum[9-10]
	
\begin{figure}[!t]
	\centering
	\includegraphics[width= 0.5\textwidth]{images/exampleImage}
	\caption{A frog}
	\label{fig_frog}
\end{figure}

\begin{figure}[!t]
	\centering
	\includegraphics[width= 0.5\textwidth]{images/fig2}
        \caption{A doggo}
	\label{fig_pup}
\end{figure}

\begin{table}[!t]
	\renewcommand{\arraystretch}{1.3}
	\caption{An Example of a Table}
	\label{table_example}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		One & Two\\
		\hline
		Three & tabs\\
		\hline
	\end{tabular}
\end{table}

\section{Conclusion}
The conclusion goes here.

\newpage

\appendices
\section{Proof of something}
	Appendix one text goes here.

\section{}
	Appendix two text goes here.

\section*{Acknowledgement}
	The author would like to thank...

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
